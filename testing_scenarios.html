<h1 id="h.tmw1mwtzn0nf">E. Testing Scenarios and Procedures</h1>
<p>When the testing environment setup is complete, testing can begin on various elements of websites and applications. The testing scenarios described in the rest of this handbook focus on common issues with web and mobile applications. </p>

<p>For people who want to learn more about basic information security but who won't get into running specific tests, the "Summary" and the "Exploitability and Impact" sections provide an overview of when and how a specific vulnerability could be exploited. The "Setup and Tests" section covers the specific steps to identify and potential security holes. </p>

<p>Not all issues are equally serious, and the potential risk of any potential issue needs to be weighed against the specific use of the application. In each test section, there is a discussion of the ease of exploiting the vulnerability, and the potential impact of a successful exploit. Not every test will be applicable in every situation. Additionally, in some testing scenarios, initial tests will be used to determine if more detailed tests are necessary.</p>

<p>Every test scenario uses a common structure:</p>

<ul>
<li>Summary</li>
<li>Exploitability and Impact</li>
<li>Setup and Tests</li>
</ul>
<p>Most of the descriptions below assume that you are using Firebug or ZAP Proxy to examine traffic sent over the internet between the application being tested and the vendor's servers.</p>

<h1 id="h.x0w34x37470m">E1 Sensitive information in URLs</h1>
<h2 id="h.hwm0291uwy92">E1.1 Summary</h2><p>It is common practice to include parameters in URLs sent from applications to the network servers hosting the applications. In many cases this is benign but if sensitive information is included in URLs it can pose a security risk for the application's users, because it may be logged in the browser or other servers that receive the URL.</p>
<h2 id="h.4js8e57p6ig">E1.2 Exploitability and impact</h2><p>Inclusion of non-sensitive information or parameters in URLs does not pose a security risk.  For example, encoding a page ID in a URL is a common practice that does not expose sensitive information.</p>
<p><figure>
<span style="width: 390.50px; height: 22.73px;"><img alt="" src="images/image82.png" style="width: 390.50px; height: 22.73px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Timestamps and character encodings are other non-sensitive uses of URL parameters</p>

<p><figure>
<span style="width: 624.00px; height: 36.00px;"><img alt="" src="images/image85.png" style="width: 624.00px; height: 36.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>However, including sensitive or personal information in a URL can put this information at risk of unintentional disclosure.  In the example below, a user's username and password has been placed in a URL during a mobile application authentication process.</p>

<p><figure>
<span style="width: 624.00px; height: 44.00px;"><img alt="" src="images/image92.png" style="width: 624.00px; height: 44.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Here, a user's personal information is part of the URL.</p>

<p><figure>
<span style="width: 608.55px; height: 38.50px;"><img alt="" src="images/image97.png" style="width: 608.55px; height: 38.50px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Sensitive information in URLs may be captured by a browser's history and in its cache (examining your browser cache is covered later in this document). Sensitive information can also be captured in server logs or other access logs. The screen captures below show that the example above with SSN and Date of Birth have been captured in the browser history and cache.</p>
<p><figure>
<span style="width: 686.40px; height: 38.50px;"><img alt="" src="images/image59.png" style="width: 686.40px; height: 38.50px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p><figure>
<span style="width: 644.50px; height: 74.99px;"><img alt="" src="images/image12.png" style="width: 644.50px; height: 74.99px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>


<p>This security issue poses an immediate risk on a shared computer, where another user could access it. Additionally, URLs containing sensitive information may be snooped from unencrypted network traffic or recorded by servers that implement or interact with the application. </p>

<p>Apps that use https eliminate the snooping vulnerability, but an application's own servers may log URLs received from users of the application. If the connection uses https, intentional misuse of URL information collected for legitimate purposes is not a significant concern, but it does raise the possibility that this information could be lost in a data breach.</p>

<p>Many applications utilize 3rd-party analytics services to track user activity for the purposes of improving the application and understanding its usage patterns.  Sensitive information in URLs may be sent to analytics or other 3rd-party services in the "Referer" field of messages.  In the image below a URL containing a valid account access code is sent to an analytics service.</p>

<p><figure>
<span style="width: 624.00px; height: 146.67px;"><img alt="" src="images/image43.png" style="width: 624.00px; height: 146.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Some services that protect users from malicious websites send some of a user's browsed URLs to their servers for analysis.  In the example below, one such service sent a URL containing a user's username and password to its servers.</p>

<p><figure>
<span style="width: 624.00px; height: 105.33px;"><img alt="" src="images/image33.png" style="width: 624.00px; height: 105.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>


<h2 id="h.49829xsxl7k2">E1.3 Setup and tests</h2><p>There is not a specific test for sensitive information in URLs. The tester should use the application in a typical fashion and examine proxy logs for any sensitive information.  The login sequence is an important part to examine closely but other transactions may contain sensitive information in URLs. Examine the traffic using either Firebug (for quick examinations and evaluations) or ZAP Proxy (for more detailed analysis).</p>
<h1 id="h.fq9rsjwj4yq4">E2. Encryption and Transport Layer Security</h1>
<h2 id="h.iwkpldsr7060">E2.1 Summary</h2><p>Encryption and Transport Layer Security are among the fundamental components of securing applications and the information they transmit and store.  Encryption converts information into an unintelligible form that can only be decoded (or "decrypted") by a recipient who holds the code required to reverse the encryption.  "Transport Layer" is a technical term for the mechanisms and pathways used to transmit information between a user and an internet service.  "Transport Layer Security (TLS)", as the name implies, refers to the suite of protocols and techniques used to protect the security, privacy, and integrity of internet communications.  TLS is often also called "SSL" (Secure Sockets Layer), particularly when used with browser and application communications.  Strictly speaking, SSL is a precursor of TLS but the terms are commonly used interchangeably.  To be consistent with other documentation and discussion, this document uses "SSL" in contexts where it is typically called SSL (such as browser traffic with a server), and "TLS" elsewhere.</p>

<p>TLS protects the integrity of internet communications in two important ways: Adding trust that the messages are coming from the authentic source and have not been tampered with, and protecting the privacy of the message contents from others who may access network traffic.</p>

<p>The Certificate mechanism creates a registration system that adds trust that the internet service is not being impersonated by someone else. There are also Message Integrity checks that protect against someone tampering with the message between the sender and receiver. (This is known as a "Man-In-The-Middle" attack).  In most cases these checks are implemented within the browser or mobile app and are not easily observed by end users.</p>

<p>TLS uses encryption to protect sensitive data from unauthorized viewing by those who can observe network traffic.  A common situation where encryption is important is a shared wifi hotspot such as a coffeehouse, airport or public library.  Communications sent without encryption can be captured and freely read by others who are on the same network.  For example, without TLS, a user's login ID and password could be snooped by someone on the network, or a user's authentication cookies could be stolen and used in a Session Hijack attack that allows an adversary to take control of someone's account (more information on authentication and cookies is included in section F5 Authentication token and cookie handling).</p>

<p>In a browser, a user can check whether https is in use by looking at a web page's URL.  If the URL starts with "https://", then the site is using a secure connection, if it begins with "http://' it is not.  This is a good basic check, but proxy logs of all of the application's requests must be examined (as described in this section) to get the full measure of https usage by an application.</p>

<p>In an educational setting TLS is a necessity in many - but not all - situations. Services that collect a username, a password, or any other potentially sensitive information should always use TLS. However, an application that doesn't require a login - like a publicly available online calculator that collects no personal information - could be used safely without TLS. In general, though, given the ease with which TLS can be implemented, it is a good thing to look for.</p>
<h2 id="h.1juqpryjxlfz">E2.2 Exploitability and impact</h2><p>Snooping of unencrypted network traffic can be accomplished with cursory technical knowledge and off-the-shelf computers, or computers with inexpensive specialized network adapters.  Programs exist to automate the process of extracting authentication tokens and other unencrypted traffic. </p>

<p>Man-in-the-middle attacks - such as tampering with unencrypted login forms or presenting false SSL certificates to mobile apps - require much more skill and effort on the part of the attacker.  The impact of data exposure from a successful exploit of Transport Layer Security can be significant - an adversary who can view network traffic may directly snoop sensitive information from the network communications, or may extract passwords or authentication codes that allow access and control of the account itself.</p>
<h2 id="h.o7vew9ih5ppt">E2.3 Setup and tests</h2>
<h3 id="h.vbqip5ovcxrs">E2.3.1 Tools</h3><p>The TLS checks for web applications can be performed with a browser and proxy. The TLS checks for mobile apps can be performed with the mobile app and proxy. Refer to the setup instructions in Section D for information on how to configure the tools.</p>

<h3 id="h.hhk99qwpsg4">E2.3.2 Tests</h3>
<h4 id="h.ums2y3iaiipo">E2.3.2.1. Check whether the login form or page is served using https (web applications).</h4><p>Load the login page and examine the transactions in the proxy to check whether or not the login page is loaded via https. Lack of https on login forms can enable man-in-the-middle attacks that tamper with the form.</p>

<p>In the example below the page is loaded without https.</p>
<p><figure>
<span style="width: 592.50px; height: 92.10px;"><img alt="" src="images/image71.png" style="width: 592.50px; height: 92.10px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>In this example the page is loaded with https.</p>
<p><figure>
<span style="width: 599.50px; height: 108.56px;"><img alt="" src="images/image61.png" style="width: 599.50px; height: 108.56px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p>Here a page loaded with http is displayed in Firebug:</p>

<p><figure>
<span style="width: 624.00px; height: 128.00px;"><img alt="" src="images/image19.png" style="width: 624.00px; height: 128.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h4 id="h.8h2oa44hb1gb">E2.3.2.2 Check whether login credentials are posted using https (web applications and mobile apps)</h4><p>Submit a login attempt and examine the transaction in the proxy.</p>

<p>In this example the credentials are submitted without https:</p>
<p><figure>
<span style="width: 547.50px; height: 207.94px;"><img alt="Screen Shot 2016-02-26 at 12.28.00 AM.png" src="images/image30.png" style="width: 547.50px; height: 210.63px; margin-left: 0.00px; margin-top: -1.34px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>In the following example the credentials are submitted with https:</p>

<p><figure>
<span style="width: 624.00px; height: 141.33px;"><img alt="" src="images/image107.png" style="width: 624.00px; height: 141.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h4 id="h.3ynwconnsi5c">E2.3.2.3. Check whether authenticated sessions continue to use https after login (both web applications and mobile apps)</h4>
<p>Some applications will use https for the login, but then switch to http after the login is complete, exposing private information and authentication tokens to the risk of network snooping.  After logging into an application, examine the transactions that come after the login to see if they are using https.</p>

<p>The examples below use http after login, exposing the user's authentication cookies to the risk of network snooping. This issue can be seen using either ZAP or Firebug.</p>

<p>In ZAP:</p>
<p><figure>
<span style="width: 550.50px; height: 222.32px;"><img alt="" src="images/image21.png" style="width: 550.50px; height: 222.32px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>In Firebug:</p>

<p><figure>
<span style="width: 624.00px; height: 257.33px;"><img alt="" src="images/image55.png" style="width: 624.00px; height: 257.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>In the next screenshot, we see an example of a service that uses https after login, protecting the user information and authentication cookies included in the responses. Note how the url begins with https.</p>

<p><figure>
<span style="width: 624.00px; height: 86.67px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 86.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>



<h4 id="h.5ieyh23nijsl">E2.3.2.4. Check whether the application uses Strict-Transport-Security headers (web applications)</h4><p>Strict-Transport-Security headers (also called HSTS for  Hypertext Strict Transport Security) tell the browser to always use https when communicating with a web site or service.  This serves as a secondary protection against an accidental http transaction due to a coding or configuration error in the application.</p>

<p>The examples below show correct use of Strict-Transport-Security headers as displayed in ZAP and Firebug.</p>

<p>In ZAP: </p>
<p><figure>
<span style="width: 554.50px; height: 166.82px;"><img alt="" src="images/image95.png" style="width: 554.50px; height: 166.82px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>In Firebug: </p>
<p><figure>
<span style="width: 624.00px; height: 350.67px;"><img alt="" src="images/image111.png" style="width: 624.00px; height: 350.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h4 id="h.oa9sl89xof6l">E2.3.2.4. Check the rigor of the service's SSL configuration</h4>
<p>The "quality" of an encrypted https connection can vary based on how the server is set up. Fortunately, free services allow server setup to be tested quickly. </p>

<p>Submit the service's domain name to the Qualys SSL Server Test website and record the results (<a href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a>).</p>

<p>NOTE: Take care to use the domain name that the app is actually hosted from.  Some services will have a main page that provides information about the service but will host the application at a different domain or subdomain.</p>

<p>On the "SSL Server Test" page, check the box labeled "Do not show the results on the boards".  This prevents the results from being publicly shared on the SSL Server Test page.</p>

<p><figure>
<span style="width: 624.00px; height: 232.00px;"><img alt="" src="images/image81.png" style="width: 624.00px; height: 232.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>



<p>Examples of SSL Server Test results are shown below. The first result is a solid review; the second result shows an online service with some serious issues.</p>
<p><figure>
<span style="width: 518.50px; height: 275.42px;"><img alt="" src="images/image101.png" style="width: 518.50px; height: 275.42px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Note that the reasons behind each issue are explained, with links to greater detail as needed.</p>
<p><figure>
<span style="width: 513.50px; height: 444.38px;"><img alt="" src="images/image03.png" style="width: 513.50px; height: 444.38px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p><hr style="page-break-before:always;display:none;">
<h1 id="h.3f8gwtp62gc0"></h1>
<h1 id="h.25vsmkjogdt8">E3 TLS for email sent by an application to users</h1>
<h2 id="h.4ps217mycyrw">E3.1 Summary</h2>
<p>Email Transport Layer Security is referred to as 'TLS' or 'starttls'.  As the name implies, email TLS protects the contents of traffic as it travels between endpoints on the internet by encrypting the content and by verifying the authenticity of the servers at the endpoints.   </p>

<p>For example, if an educational application sends a class update to a teacher's email account, TLS can be used to encrypt the email as it travels from the application's email server to the teacher's email server.  This is analogous to the protection provided by https between a user's browser and an application's servers.</p>

<p>One more detail of email TLS is that both ends of the connection must support it, and it is up to the server sending the mail to request that it be used for the transfer of information.  (This is where 'starttls' comes from, it's the name of the request for TLS from the server sending the mail).  From the previous example, if the application wanted to send email to a teacher's email account using TLS, the application's mail server would initiate the connection with the teacher's mail server ask for TLS with a starttls request. The teacher's mail server will reply whether it's supported, and if so the connection encryption would be set up.</p>
<h2 id="h.5niv7akow7s7">E3.2 Exploitability and impact</h2>
<p>Connections between email servers are on the inner (non-public) segments of the network,  where few would have access to the network traffic. This makes lack of email TLS a much smaller threat than sending the same content from a mail server to a user's email client without encryption &mdash; for example if the user is using an airport wifi to read the message and the email provider does not encrypt the messages between its server and the user's client program. The impact of a successful exploit depends on the sensitivity of the information in the intercepted emails.</p>
<h2 id="h.j1roabe90h4r">E3.3 Setup and tests</h2>
<h3 id="h.8py9kcjqa0cc">E3.3.1 Email header inspection</h3><p>The definitive way to test whether an application's emails use TLS between mail servers is to directly examine the email headers of a mail sent from the application to one of its users, where the presence of TLS will be noted if it was used.  </p>

<p>For this test, the recipient email account's servers must be confirmed to accept TLS for incoming mail messages.  If this is not known or needs to be verified, the "checktls.com" service can be used to test the recipient email address.</p>

<p>Browsing to checktls.com brings up a form where the email can be entered (no mail will be sent to the recipient address, it's only used to contact the server). Enter the recipient email address as indicated below and click "Try It".</p>

<p><figure>
<span style="width: 537.50px; height: 297.18px;"><img alt="" src="images/image18.png" style="width: 537.50px; height: 297.18px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>The results will indicate whether the mail server accepts incoming TLS connection requests. Ideally the "Confidence Factor" will be 100.  A sample result is shown below.</p>


<p><figure>
<span style="width: 624.00px; height: 185.33px;"><img alt="" src="images/image68.png" style="width: 624.00px; height: 185.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Once you have confirmed that your email address accepts TLS for incoming email, you are ready to inspect the headers of incoming messages.  The steps for displaying email headers differs by email client.  The menu item is typically labeled "show original message", "show headers", or similar.</p>

<p>If the mail was sent with TLS, it will be noted in the headers with a description including the letters "TLS".  The syntax will vary but will always include the term "TLS".  An example is below.</p>
<p><figure>
<span style="width: 624.00px; height: 126.67px;"><img alt="" src="images/image78.png" style="width: 624.00px; height: 126.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h3 id="h.9wjy7cj5r8zr">E3.3.2 Google's Safer Email Transparency Report</h3><p>Google's Safer Email Transparency Report site posts daily percentages of mail sent and received using TLS for the domains with the most traffic to and from Google's mail servers. </p>
<p>http://www.google.com/transparencyreport/saferemail/</p>

<p>For mail coming in to gmail, the mail will only be sent with TLS if the sending side requests it.  Google always requests TLS for email connections, so for mail leaving Google it will only be sent with TLS if the receiving domain supports TLS.  The Safer Email website allows searches by domain name.  If the application being tested sends enough mail to gmail users that it shows up on this list, it's a good way to check whether the app is sending mails with TLS.</p>

<p>As an example, the screenshot below shows the results for a particular application.  Google reports that 0% of the mail entering Google from this application's mail servers  is sent with TLS. </p>


<p><figure>
<span style="width: 624.00px; height: 188.00px;"><img alt="" src="images/image100.png" style="width: 624.00px; height: 188.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>This means that the application's  servers are not requesting TLS when sending email.  Outbound mail is not listed because not enough mail flows from Google to this application's servers to be recorded in this dataset.  However, mail coming in to gmail is of more interest because mail from the app to its users is more likely to contain student information.</p>

<p>The image below shows the results for the same application after they enabled TLS for outgoing email.</p>

<p><figure>
<span style="width: 624.00px; height: 180.00px;"><img alt="" src="images/image23.png" style="width: 624.00px; height: 180.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h3 id="h.fwm7cp7yqcyi">E3.3.3 checktls.com</h3><p>Checktls.com is discussed above in the context of confirming a tester's email address will accept email TLS connections.  The same test can be performed on an application's mail servers, but in practice many servers accept TLS but do not request TLS for outgoing mail.  Because of this, the checktls.com test is not sufficient to confirm that an application requests TLS for outgoing mail.</p>

<h1 id="h.bfgcmg2c7m2"></h1><hr style="page-break-before:always;display:none;">
<h1 id="h.kzr7tcxasrqc"></h1>
<h1 id="h.ad79s4u8zvhc">E4 Caching and history storage of pages with sensitive information</h1>
<h2 id="h.s6l7mchrhbia">E4.1 Summary</h2><p>In computer systems, the term "caching" refers to the practice of keeping a local copy (or "cache") of information so that it may be accessed again quickly if needed later on.  Browsers improve performance by storing copies of web pages a user views, so that they can displayed again later without the need to fetch them again over the network. </p>

<p>Though caching improves the performance of a browser, caching of pages with sensitive information can expose the information to unauthorized access.  Because of this, there are directives that a web service can include in message headers to prevent pages from being stored in a browser's cache.</p>

<p>The browser's history is subtly different than the cache, but also can be used to show the contents of a page previously loaded by a user.  If the page contains sensitive information and the user has signed out of the service since viewing it, it should not be displayed by the "back" button or history mechanism without first requiring a new login by the user.  (Note that it is OK for "back" or history to display the page if the user is still logged in to the service).</p>

<p>This section will describe how to do browser-based tests for browser caching of sensitive pages, and how to inspect message headers to look for cache control directives.</p>

<p>NOTE: Make sure that you have cleared your history, cookies, and cache as described in Section D.</p>
<h2 id="h.mh1a5lue9obq">E4.2 Exploitability and impact</h2><p>The risk posed by browser caching of sensitive information is mostly limited to access of that information from the same computer it was originally viewed on.  The most common scenario would be a shared-use computer where one user could potentially view information from another user's browsing history.  The impact depends on the type of information that is cached and is limited by the scope of the information and the fact that the opportunity to access the data is restricted to the one-time snapshot of the information.</p>

<h2 id="h.h3wu53hfc3t5">E4.3 Setup and tests</h2>
<h3 id="h.vwc3l336fxrh">E4.3.1 Overview</h3><p>Applications can include caching directives in response headers, to instruct the browser how it should store the result in history and cache buffers.  In practice, different browsers handle cache and history related directives differently.  Because of the complexity of reviewing cache directives on individual responses, the recommended usage is to directly test the history and caching behavior of the application using the "Browser-based history test" and "Browser cache inspection" documented later in this section.  Proxy logging of the user session can be used to look for pages of interest that can be searched for in the cache.  </p>

<p>The absence of some or all of the recommended cache-related directives in responses can be used as another clue when looking for sensitive data responses that may be stored in the browser disk cache. The following sections describe header response inspection, history checking and browser disk cache inspection.</p>
<h3 id="h.7ps9ful4q6r">E4.3.2 Header response inspection</h3><p>It is possible to examine the headers of the http responses to sensitive page loads to see if the cache controls that prevent cache and history storage are present.  In practice, different browsers handle cache and history related directives differently.  There is some consensus that the combination of directives in the screenshot below will prevent caching or history storage across the major browsers.  Note that "Expires" can be set to '0' or a time in the past.  Also note that GET responses can be cached or stored in history but POST responses are not cached.</p>

<p>Cache headers displayed in ZAP:</p>
<p><figure>
<span style="width: 624.00px; height: 170.67px;"><img alt="" src="images/image99.png" style="width: 624.00px; height: 170.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Cache headers displayed in Firebug:</p>
<p><figure>
<span style="width: 624.00px; height: 349.33px;"><img alt="" src="images/image79.png" style="width: 624.00px; height: 349.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>


<p>An informative discussion of cache parameters and how they are handled by browsers can be found on Stack Overflow: </span><a href="http://stackoverflow.com/questions/49547/making-sure-a-web-page-is-not-cached-across-all-browsers">here</a>.</p>
<h3 id="h.i8oxvlmno7bx">E4.3.3 Browser-based history test</h3><p>There is a straightforward way to check for history storage of sensitive information directly from the browser.  The steps are as follows:</p><ol><li>Log in to a service and browse to a page with sensitive information.  In the example below a class roster is viewed from a teacher account.</p>
<figure>
<span style="width: 624.00px; height: 269.33px;"><img alt="" src="images/image116.png" style="width: 624.00px; height: 269.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure><br></li>
<li>Sign out of the service</li>
<li>Click on the browser's "Back" button. If the original page, with logged in user information, is displayed without requiring a new login, this indicates that the page was stored in the browser cache.  <br></li></ol><p>This illustrates one way storing history with sensitive information can lead to unintended disclosure. On a shared computer, one user can sign out of the account, and a different user can still access personal information from the first user's account.</p>

<h3 id="h.8yja7zn6i6t7">E4.3.4 Browser cache inspection</h3>
<p>In most cases, if an application passes the Header response inspection and the Browser-based history test, it will not be necessary to inspect the content of a browser's cache. However, inspecting the content of a browser's cache can provide additional detail about how an application functions, and what data it caches on your computer.</p>

<p>To inspect what is stored in the browser's cache, enter "about:cache" in the browser's URL field.  Note that the disk cache is of particular interest since its contents will persist after the browser program has been closed and restarted.  Click on "List Cache Entries" under "disk" to see the disk cache entries </p>

<p><figure>
<span style="width: 624.00px; height: 352.00px;"><img alt="" src="images/image34.png" style="width: 624.00px; height: 352.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p>The URLs of the cached pages will be listed and specific pages of interest can be searched.  The entry for the roster page shown above is present in the browser disk cache.</p>
<p><figure>
<span style="width: 391.50px; height: 31.36px;"><img alt="" src="images/image05.png" style="width: 391.50px; height: 31.36px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p>Clicking on the URL name will load a representation of the raw source of the page.  It is not easily human-readable but it is possible to search on sensitive terms to confirm that they are present in the cached page.  For example, the account information for "Demo Student" is shown below in the cached page contents.</p>
<p><figure>
<span style="width: 621.00px; height: 70.00px;"><img alt="" src="images/image01.png" style="width: 621.00px; height: 70.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Note that the URL shown in the browser when sensitive info is displayed may not correspond to the exact request that loaded the sensitive information itself.  Using a proxy to observe all the requests generated when a page of interest is displayed can be helpful in finding which URLs to look for in the browser's cache storage.</p>

<p>Additionally, if specific pages looks like they might contain sensitive information, you can do additional testing using ZAP Proxy logs cross referenced against the contents of the browser cache. This will allow you to zero in on specific pages. </p>

<h3 id="h.loc23z8234lk">E4.3.5 Recommended test steps</h3><p>Perform the browser-based history test on a representative page containing user information.  Using browsing history, proxy logs and response headers as a guide for pages of interest, inspect the browser's disk cache for stored pages containing sensitive information in the page contents or URL.</p>
<h1 id="h.x4jmiwl0vza6"></h1><hr style="page-break-before:always;display:none;">
<h1 id="h.qsjco01x69rn"></h1>
<h1 id="h.jgbj7m6ef85r">E5 Authentication token and cookie handling</h1>
<h2 id="h.gzsbf5qtrhuw">E5.1 Summary</h2>
<p>Cookies are small text strings sent by servers to browsers in http responses as the user interacts with a web service.  The browser saves the cookie values and includes them with subsequent http requests to the same domain.  The use of cookies allows web services to maintain the "state" of a session so that previous interactions can be taken into account when new requests arrive.  Cookies are used for many purposes such as setting identifiers for ad networks and analytics services, recording the first page on a site a user visited, and storing authentication tokens that give access to an active login session.  </p>

<p>Authentication cookies are the ones most relevant to assessing the security of an online service.  When a user first logs in, the service responds by setting an authentication cookie that identifies this user session (these cookies are often referred to as "session cookies" for this reason; in this document we will refer to them as "authentication cookies").  When the user sends the next request, the service can look up the session ID in the cookie and associate it with the user's active login session.  Without this the user would need to supply the password each time a new page was loaded.</p>

<p>Protecting authentication cookies is important because if an adversary can get access to it, it can be installed in the adversary's browser or included in specially crafted http requests.  This would give the adversary full access and control to the user's account.  This attack is known as "</span><a href="https://en.wikipedia.org/wiki/Session_hijacking">session hijacking</a>" or "sidejacking".</p>

<p>The rest of this section will show how to install and use a cookie editor to examine and modify cookies in a browser.  The Test Procedures section on checking authentication token handling and cookie flags outlines the cookie tests that use the cookie editor.</p>

<p>More information on authentication cookies can be found at the links below: </p><ul><li><a href="http://edtechinfosec.org/2014/11/25/session-cookies/">Edtechinfosec: Session Cookies</a></li>
<li><a href="http://www.troyhunt.com/2013/03/c-is-for-cookie-h-is-for-hacker.html">Troy Hunt:C is for Cookie, H is for Hacker</a></li>
</ul>
<h2 id="h.go1005ch8716">E5.2 Exploitability and impact</h2><p>An adversary in possession of a user's authentication cookie or token can easily exploit them to access and control most or all of the target's account through a Session Hijacking attack.  The primary protection against this is the use of Transport Layer Security (TLS / https) to prevent snooping of the cookie or token values from network traffic. (See the "Encryption and Transport Layer Security " section of this document for background and verification tests for TLS). As discussed in the "Sensitive Information in URLs" section of this document, authentication tokens placed in URLs can be susceptible to unauthorized access. The tests in this section focus on mitigating these risks by preventing the access or limiting the scope of their usefulness in attacks.</p>

<p>Another way that authentication tokens can be accessed without authorization is through cross-site scripting (XSS) attacks that inject malicious scripts to a user's browser to read and collect authentication cookie values. However, testing for XSS vulnerabilities is beyond the scope of this information security primer.</p>
<h2 id="h.hfasjjvfytwr">E5.3 Setup and tests</h2>
<h3 id="h.jjxwgd1wcntq">E5.3.1 How to identify authentication cookies</h3>
<p>Authentication cookies, commonly also called session cookies, are often easy to spot because they contain "sess" or "session" or "sess_id" in their names.  Many popular platforms use standard names for session cookies, and a list of these is included below.</p>
<p>asp.net_sessionid</p>
<p>aspsessionid</p>
<p>cfid</p>
<p>cftoken</p>
<p>jsessionid</p>
<p>phpsessid</p>
<p>sessid</p>
<p>sid</p>

<p>However, there are no hard and fast rules governing the names of cookies. Many authentication cookie names are unique to the service, and may not be named in a way to make it clear it's a session/authentication cookie.</p>

<p>To read and search for cookies, use the Advanced Cookie Manager described in Section D.3.</p>

<p>To confirm that a cookie is an authentication cookie, or to search for it in case the name is not apparent, log in to the web site.</p>

<p>Then, using the Cookie Manager, delete the candidate cookie and reload the page.  If the page fails to reload in to the login session, the cookie in question is an authentication cookie.  Note that some services have more than one authentication cookie and all must be present for full account access. An illustration of deleting a cookie using the cookie editor is shown below.</p>
<p><figure>
<span style="width: 624.00px; height: 356.00px;"><img alt="" src="images/image32.png" style="width: 624.00px; height: 356.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<h3 id="h.lrlgliorty2o">E5.3.2 Flags that protect authentication cookies</h3><p>Cookies have optional flags that the application can set to control how a browser handles them.  Of these, the 'httpOnly' and 'secure' flags are important to protecting authentication cookies from unauthorized access.   </p>

<p>The httpOnly flag prevents scripts from reading a cookie's contents. In a cross-site scripting attack (commonly called "XSS"), an adversary is able to inject a malicious script to run in a user's browser. If such a script can read an authentication cookie, it can send it to the adversary for use in a session hijacking attack. The httpOnly flag cannot prevent a successful cross-site scripting attack but it does prevent the cookie, and the account it protects, against compromise in the event of such an attack.</p>

<p>The secure flag prevents the browser from sending a cookie in an http (unencrypted) request.  In an implementation that is using https, this protects against an accidental exposure of the cookie through an unintentional http request.  In some implementations the use of load balancers to even out internal server loading can preclude the use of the secure flag for authentication cookies.  In those cases, HSTS (Hypertext Strict Transport Security) is important to prevent the browser from sending any http requests to this domain.  (See the Encryption and Transport Layer Security section of this document for details of HSTS).</p>

<p>Both of these flags can be checked in the cookie editor by selecting the authentication cookie and examining the flags settings. In the example below, both the httpOnly and secure flags are set.</p>
<p><figure>
<span style="width: 624.00px; height: 344.00px;"><img alt="" src="images/image63.png" style="width: 624.00px; height: 344.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<h3 id="h.lxaguwf157fz">E5.3.3 Invalidation of authentication cookies at logout</h3><p>Authentication cookies should be invalidated when a user logs out of an application.  If they remain valid after a logout, then an adversary in possession of an authentication cookie value can continue to access the account.  Put another way, the user cannot limit the scope of a possible attack by logging out of the application.</p>

<p>Using a cookie editor, It is straightforward to check whether authentication tokens are invalidated at logout. The sequence is described and illustrated below</p><ul><li>Log in to the service and go to a page that indicates the user is logged in.</li>
</ul>

<p><figure>
<span style="width: 624.00px; height: 208.00px;"><img alt="" src="images/image49.png" style="width: 624.00px; height: 208.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<ul><li>Using the cookie editor, filter on this domain's cookies and save them to file by clicking the export icon as shown below. Pick a descriptive name for the file.</li>
</ul>
<p><figure>
<span style="width: 624.00px; height: 341.33px;"><img alt="" src="images/image35.png" style="width: 624.00px; height: 341.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<ul><li>Log out and confirm that the same URL no longer indicates that the user is logged in.</li>
</ul>
<p><figure>
<span style="width: 624.00px; height: 214.67px;"><img alt="" src="images/image00.png" style="width: 624.00px; height: 214.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<ul><li>Using the cookie editor, restore the cookies from the file saved in the previous steps.</li>
</ul><p><figure>
<span style="width: 700.50px; height: 450.47px;"><img alt="" src="images/image22.png" style="width: 700.50px; height: 450.47px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<ul><li>Reload the URL recorded earlier, and check whether the page indicates the user is logged in or not.  If the user is again logged in after restoring the cookie, this indicates that the authentication cookie was not invalidated at logout.  This can be further confirmed by exercising functionality of the application to see if access is allowed.</li>
</ul>
<h3 id="h.hz9cbgh9f8dp">E5.3.4 Logout links</h3><p>For users, best practice to protect personal information is to log out when done using an application.  Doing so invalidates authentication tokens from the session, thus limiting the scope of any possible unauthorized use of those tokens.  Applications must support this by providing a logout mechanism and making it easy to access from any page that a user can visit while logged in.</p>

<p>The check for this is straightforward.  Exercise the functional areas of the application, making sure that the logout mechanism is available at any page or view that requires authentication to access.</p>

<p>Note that many applications place the logout link in a dropdown menu, as shown below, and make that dropdown menu available on all pages in the application.</p>
<h3 id="h.7lq1864568l4"><figure>
<span style="width: 164.66px; height: 296.17px;"><img alt="" src="images/image96.png" style="width: 164.66px; height: 296.17px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></h3>
<p>Frequently, mobile apps on a tablet or phone will keep you logged in longer than web apps or desktop apps. These logins will often persist when an app is powered down and restarted. Because of this tendency, testing the duration of logins on devices is a critical part of the testing process. If you identify an application that keeps a user logged in after a device has been powered down and restarted, that poses a security risk for any user in an environment where devices are shared.</p>
<h3 id="h.ydp7yshpkmk5"></h3>
<h1 id="h.rbaoviif8nfx"></h1><hr style="page-break-before:always;display:none;">
<h1 id="h.jwbdbs6jeus0"></h1>
<h1 id="h.o0yfi4ju8qc4">E6 Password handling</h1>
<h2 id="h.p0qyv29uhye">E6.1 Summary</h2><p>Most applications employ usernames and passwords to provide individual access to user accounts.  Because usernames and passwords provide full access to an account, protecting usernames and passwords is essential. Some aspects of password handling cannot be observed by an end user - for example, what hashing scheme has been used for internal password storage. Others can be observed or inferred through end-user tests. This section covers the tests that can be performed by an end user without access to the internals or implementation details of an application.</p>
<h2 id="h.bycob2ftdmmd">E6.2 Exploitability and impact</h2><p>If an adversary gains access to an account's username and password, it is highly exploitable - the entire account and its contents can be accessed. But, the vulnerabilities described in this section all require first gaining access to a target's email account, network traffic, or the service's internal storage. This moderates the risk that these vulnerabilities can pose.</p>
<h2 id="h.wpt7namartcy">E6.3 Setup and tests</h2>
<h3 id="h.4m74lanyrk6d">E6.3.1 Encryption and Transport Layer Security</h3>
<p>Perhaps the most important protection for passwords is safeguarding them as they are sent from the browser when the user logs in. See the Encryption and Transport Layer Security section of this document for detailed information on how to test an application's Transport Layer Security Practices. Issues with encryption and transport layer security can pose serious risks to the integrity of an application, which include compromised user passwords.</p>
<h3 id="h.9xo3mg78sh5h">E6.3.2 Recovering lost passwords</h3>
<p>There is not a uniform standard for secure handling of account recovery from lost passwords. However, there are some practices that are widely recognized as security risks.</p>
<ul>
<li>Putting a new password in an email to the user:  Email has a long life and may be transported without encryption on some links between the sender and the receiver.  It's better to send an (https) password reset link that expires after one use or a short time if not used.</li>
<li>Sending or displaying a user's current password:  Best practice for password storage is to perform a one-way hash and store the hash result.  This requires the passwords to be "cracked" in the event of a breach of the password files.  If an application is able to show or send a user's current password, it indicates that it has been stored in plain text or other recoverable format.</li>
</ul>
<ul>
<li>Note: some services (generally for early elementary students) store student passwords in plain text so that they can be displayed to teachers for easy recovery in case a student loses a password. When evaluating this practice by a particular application, it's important to consider what information is protected by the student passwords, and what other protections are in place to secure the teacher account that can view the student passwords. It is never appropriate for teacher or parent passwords to be stored in plain text or recoverable format.</li>
</ul>
<ul>
<li>Security questions: Security questions often rely on fixed information that can be guessed or never changes. As a result, security questions do not provide reliable, consistent protection for end users. </li>
</ul>

<h1 id="h.9dzibh2zsmhu">E7 Username enumeration</h1>
<h2 id="h.mflcozt3veb3">E7.1 Summary</h2><p>If an application reveals or confirms which usernames are valid within its system, it may enable or increase the chances of other attacks. For example, the first step in a brute-force password attack is finding valid usernames. If a username is the account holder's email address, it may be possible to identify or contact an application's users or construct a phishing or other social engineering attempt.</p>

<p>It's important to note that apps that allow users to choose their usernames must necessarily indicate if a username is already taken. Because of this, this check is most relevant for services that do not allow users to set their own usernames.  A service where a district administrator assigns usernames for students is a good example of an application that should be careful not to expose or confirm valid usernames.  Services that allow users to choose their usernames should still limit the confirmation of valid usernames to the account creation activity.</p>
<h2 id="h.12n9dlp4hivh">E7.2 Exploitability and impact</h2><p>The most common place for usernames to be enumerated is at the public-facing login and password recovery interfaces, making a vulnerability easy to exploit.  However in most cases a valid username is only part of the information needed to attempt a larger exploit or attack. So, it is a significant but low-severity problem. But it is also an indicator of the overall defensive posture of the application. Another consideration for impact is how the username could be used in another attack.  Exposing valid accounts based on names, email addresses or student ID numbers poses more risk than exposing account names that are unique to a given application.</p>

<p>Username enumeration attacks are most relevant for systems that hold highly sensitive data, or in systems where a compromised administrative account can provide access to a larger data set. Username enumeration can be a stepping stone to a larger, more catastrophic compromise.</p>
<h2 id="h.roihhrjluacf">E7.3 Setup and tests</h2><p>The tests for this section focus on the user login and password recovery interfaces, and can be conducted directly from the browser.</p>
<h3 id="h.pqjlaodys6pv">E7.3.1 User login</h3><p>Attempt two types of logins. First,  use both an invalid username; then use a valid username but incorrect password. In both cases, the application should not reveal if the username was valid.  The following image is an example of a proper response.  It states that either the username or password was incorrect without identifying which one wasn't recognized.</p>
<p><figure>
<span style="width: 624.00px; height: 70.67px;"><img alt="" src="images/image77.png" style="width: 624.00px; height: 70.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure>In contrast, messages like the ones shown below reveal the validity of the username used in the login attempt.</p>
<p><figure>
<span style="width: 543.50px; height: 104.52px;"><img alt="" src="images/image67.png" style="width: 543.50px; height: 104.52px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p>As noted above, username enumeration poses a relatively small risk on its own, but level of protection can be used as a factor in evaluating the security practices of elements that are more difficult to observe.</p>
<h3 id="h.ft0vj9gi6k2z">E7.3.2 Password recovery</h3><p>Exercise the password recovery interface by requesting password recovery for a valid and invalid username.  Check whether the application gives different responses for valid and invalid usernames.   Apps will often simply state that an email is sent, whether the provided username was valid or not.  This is a proper response as it doesn't reveal the validity of the username. Applications may also respond that "if an account with that username exists, a mail has been sent."  </p>
<p><figure>
<span style="width: 468.50px; height: 60.81px;"><img alt="" src="images/image88.png" style="width: 468.50px; height: 60.81px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p><figure>
<span style="width: 358.50px; height: 104.16px;"><img alt="" src="images/image06.png" style="width: 358.50px; height: 104.16px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>Some examples of responses that reveal invalid usernames are shown below.  Responses such as these can be compared to the response for a valid username to determine whether usernames are valid for the application.</p>
<p><figure>
<span style="width: 342.69px; height: 33.50px;"><img alt="" src="images/image54.png" style="width: 342.69px; height: 33.50px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p><figure>
<span style="width: 588.00px; height: 50.00px;"><img alt="" src="images/image64.png" style="width: 588.00px; height: 50.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p><figure>
<span style="width: 624.00px; height: 49.33px;"><img alt="" src="images/image86.png" style="width: 624.00px; height: 49.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<hr style="page-break-before:always;display:none;">
<h1 id="h.20c6a5c1ov40"></h1>
<h1 id="h.84zlnvdl3nqp">E8 Observation of websockets traffic</h1>
<h2 id="h.vapinpbwcs48">E8.1 Summary</h2><p>Websockets provide a communication link separate from http that browsers and application servers can use to pass information back and forth.  It is normally a secondary form of communication that is connected after the web application loads into the browser.  If an application uses websockets, the traffic is of interest for security testing because it may contain personal information of the account holder or other users of the system.</p>
<h2 id="h.61n72nw4mfkk">E8.2 Exploitability and impact</h2><p>The exploitability and impact related to websockets traffic depends on what information the traffic contains, and whether it is encrypted.  Unencrypted websockets traffic could expose sensitive information, but an observer would need access to the network traffic to access the information.  Sensitive information about users other than the account holder could be viewed by anyone with an account, regardless of encryption during transport.</p>
<h2 id="h.8fjtmad0hqb3">E8.3 Setup and tests</h2><p>Refer to the proxy setup section C4.5 Observing websockets using ZAP proxy for details of how to view websockets in OWASP ZAP, and how to check whether the websockets link is encrypted.</p>

<p>There is not a specific set of tests to exercise websockets. Rather, the functionality of the application should be explored during testing, and then websockets traffic (if any) observed for its contents and encryption.  Steps for these observations are described below.</p>
<h3 id="h.3060boikmptv">E8.3.1 Check contents of websockets traffic for sensitive information</h3><p>If an application uses websockets, check the contents of the messages for sensitive information.  Note that sensitive information about the account holder is not a security concern if it is sent over an encrypted connection. It is a concern if the information is related to other users of the system.  The image below shows an example of a websockets message containing student personal information for a different student than the logged in account holder (this is also an example of Information Leakage, covered in Section E9 of this document).</p>
<p><figure>
<span style="width: 624.00px; height: 116.00px;"><img alt="" src="images/image74.png" style="width: 624.00px; height: 116.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<h3 id="h.pgk5io8rnrmf">E8.3.2 Check whether the websockets connection is encrypted</h3><p>An unencrypted websocket connection is not a concern if the information transferred over the websocket is not sensitive. However, an encrypted connection is always more secure as it will protect traffic that may not be observed during testing or may be added in future releases of the application.  Another consideration is that an unencrypted websocket connection can expose a session cookie if the websocket has the same domain as the main service and the session cookie's 'secure' flag is not set.</p>

<p>From the websockets view of OWASP ZAP, it's possible to determine whether the websockets traffic is sent over an encrypted connection.  First, select the websockets channel of interest:</p>
<p><figure>
<span style="width: 465.00px; height: 134.00px;"><img alt="" src="images/image93.png" style="width: 465.00px; height: 134.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p>Then, click the button with green arrows to bring up the initial connection transaction for the websocket.</p>

<p><figure>
<span style="width: 624.00px; height: 109.33px;"><img alt="" src="images/image28.png" style="width: 624.00px; height: 109.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>The details of the connection will be displayed in the upper transaction pane.  Check whether the connection was initiated with https (encrypted) or http (not encrypted).   Note that port 443 is typically reserved for secure connections but the proper check is to look at the connection URL, not the port number.  Ports other than 443 may support a secure connection and port 443 does not guarantee a secure connection. In the example shown below, the connection is encrypted.  The authentication cookie is included in the transaction and protected by the encrypted connection.</p>


<h1 id="h.50hp1hjn5z6b"><figure>
<span style="width: 624.00px; height: 192.00px;"><img alt="" src="images/image94.png" style="width: 624.00px; height: 192.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></h1>

<p>Evaluating the potential risks of websockets traffic requires examining what information, if any, is sent via websockets traffic, and whether or not that information is encrypted. As noted above, while encrypting websockets traffic is not always essential, it is a good step, and can also help work as an indicator of the overall level of thought into defensive strategies used by the application.</p><hr style="page-break-before:always;display:none;">
<h1 id="h.tynmunvkrhcu"></h1>
<h1 id="h.krhp5dinabwe">E9 Information leakage</h1>
<h2 id="h.608106vxg5v2">E9.1 Summary</h2><p>Information leakage occurs when an application reveals or "leaks" sensitive information about the system or its users.  In this section of this test plan, the focus is on leakage of sensitive information about an application's users.</p>
<h2 id="h.5akdv6pporg0">E9.2 Exploitability and impact</h2><p>The exploitability and impact of information leakage depends on what information is leaked and how difficult it is to observe the leaked information.  For example if an application embeds a student's date of birth (DOB) and home address in an https (encrypted) response to populate a name on a dashboard page (without displaying DOB or home address on the page), the impact is serious but an adversary must first take control of a user's account to view the information.  If the application does not use https for the transaction, an adversary must then only observe the unencrypted network traffic to access the sensitive information.</p>

<p>Information that is compromised via information leakage will - in some cases - be damaging in its own right. In other cases, it can be used as a foundation for other more sophisticated attacks. As a result, it is important to track when information leaks out, and then think about other ways that information could be used to structure other attacks. </p>
<h2 id="h.qqzeo9fxpqfu">E9.3 Setup and tests</h2><p>Because applications are implemented in different ways, there is no standardized method to test for information leakage. Testers should perform a full range of user interactions with the application and be watchful for extra information in system responses and transactions.  Common ways that information can be leaked include (but are not limited to): </p><ul><li>Request for user information returns sensitive information beyond what is necessary to display a page. This can be checked by loading a page (like a user profile page) and examining http/https responses for extra information;</li>
<li>Password recovery mechanism reveals user email account (if username is not email), or user's real name;</li>
<li>Teacher account requests for class roster information return sensitive information beyond what is necessary about each of the students in a class;</li>
<li>Websockets or other dynamic content update messages contain information about users beyond the scope of the logged-in account.</li>
</ul>
<p>All of the examples listed above are real problems that have been observed and fixed in educational technology applications.</p>

<h3 id="h.tffq0u5vsua6">E9.3.1 Examples of Information Leakage</h3><p>As seen in the example below, information leakage can reveal a broad range of information. When evaluating the potential significance of information leakage, it is necessary to evaluate whether the leak is sufficiently dangerous on its own, or whether the information could be used as the foundation for other, more complex attacks. For example, knowing a user ID isn't necessarily dangerous, but if the application uses user IDs in the URL (as described in E1 Sensitive information in URLs) an ID could potentially be used to craft an attack and compromise a user account.</p>

<p>Additionally, information leakage can be used to assess the overall defensive posture of an application. If an application leaks information in places where it shouldn't, it can be an indicator of weak practices in areas that we cannot observe.</p>
<h4 id="h.21x8s0z82hry">E9.3.1.1 Email leakage</h4><p>In the example shown below, a student password reset request reveals the email address of the student's parent</p>
<p><figure>
<span style="width: 548.50px; height: 101.09px;"><img alt="" src="images/image17.png" style="width: 548.50px; height: 101.09px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h4 id="h.56iz4o3483a7">E9.3.1.2 Leaking names and emails</h4><p>In the example shown below, an application has different responses for conditions where an access code has already been used and an attempt is made to reuse the code. Together, the messages reveal a parent's full email address and the parent's first name and last initial.</p>

<p><figure>
<span style="width: 624.00px; height: 78.67px;"><img alt="" src="images/image103.png" style="width: 624.00px; height: 78.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p><figure>
<span style="width: 624.00px; height: 101.33px;"><img alt="" src="images/image102.png" style="width: 624.00px; height: 101.33px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h4 id="h.94oxul5fhdmt">E9.3.1.3 Leaking Student Information</h4><p>In the example shown below, a request for student name information to be used in a class roster display also returns the student's userID, password hash and gender.</p>
<p><figure>
<span style="width: 531.50px; height: 150.76px;"><img alt="" src="images/image69.png" style="width: 531.50px; height: 150.76px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h4 id="h.rp7yummv8hnm">E9.3.1.4 Leaking full name, school, state, and user ID</h4><p>Here, an application displays the first name, school name and state of a "daily winner", but the data request visible in the proxy also returns the student's last name and numeric userid.</p>
<p><figure>
<span style="width: 299.50px; height: 65.87px;"><img alt="" src="images/image84.png" style="width: 299.50px; height: 65.87px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<p><figure>
<span style="width: 577.00px; height: 32.00px;"><img alt="" src="images/image13.png" style="width: 577.00px; height: 32.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<h4 id="h.e2qh0r4gqtn7">E9.3.1.5 Leaking username, activity information, name, and teacher ID</h4><p>As seen in the "Observation of websockets traffic" section, this websockets message reveals information about a different student than the one who is logged in.</p>
<p><figure>
<span style="width: 624.00px; height: 116.00px;"><img alt="" src="images/image74.png" style="width: 624.00px; height: 116.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<h1 id="h.f3h1kbxtdkob"></h1><hr style="page-break-before:always;display:none;">
<h1 id="h.8fusgnd4eyl"></h1>
<h1 id="h.rnno329obb2d">E10 API authentication checks</h1>
<h2 id="h.aghuyfymsb8f">E10.1 Summary</h2><p>Many applications use APIs to retrieve information from the application's servers. API stands for "Application Programming Interface".  In simple terms, an API will typically fetch raw data from the server to be rendered for display by the application, as opposed to fetching pre-formatted HTML pages.  APIs are more common for mobile applications than browser-based applications but are utilized by both.  The URL for an API will commonly include "api" in the URL, and will have parameters in the URL or in the message body.  Examples of APIs will be shown in the "Setup and tests" discussion below.</p>

<p>The tests in this section focus on checking whether information from the tester's account can be accessed through an API without proper authentication.  </p>

<p>More advanced tests that attempt to modify API parameters are beyond the scope of this section of the test plan, because they are likely to access other users' information if the application does not implement proper controls.</p>
<h2 id="h.bge6s9opq4oq">E10.2 Exploitability and impact</h2><p>Since APIs can be accessed by anyone on the network, security flaws in APIs are highly exploitable and can be used in remote attacks.  The impact of these types of exploits is dependent on the kinds of information that can be retrieved from the API, but can be very serious and potentially expose all the information that the application can access to an attacker.</p>
<h2 id="h.oayw74esjvsl">E10.3 Setup and tests</h2><p>For browser-based applications, Firebug or OWASP ZAP (external proxy) can be used to examine the application's network transactions. For mobile applications, the mobile device must be configured to send its network transactions through OWASP ZAP.  Refer to the setup section for proxies and mobile devices for more details.</p>

<p>Since each application is different, the first step is to exercise the functionality of the application and examine the network transactions for API requests.  The URL of an API will often include 'api' in the URL.  Regardless of this, the typical characteristics of API calls are requests containing parameters in the URL, which return raw data and not formatted HTML.  This image shows an example of an API request:</p>
<p><figure>
<span style="width: 624.00px; height: 146.67px;"><img alt="" src="images/image48.png" style="width: 624.00px; height: 146.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>The response when logged in is below, returning information about students in the class.</p>
<p><figure>
<span style="width: 624.00px; height: 222.67px;"><img alt="" src="images/image109.png" style="width: 624.00px; height: 222.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>If the API access is a GET request, the browser can be used to test if the same request works without authentication. In a browser that is not logged in to the application, paste the URL into a browser's address bar and load the page into the browser. The response should not include information from the account and will likely indicate that the user is not authenticated.</p>


<p><figure>
<span style="width: 525.50px; height: 87.58px;"><img alt="" src="images/image14.png" style="width: 525.50px; height: 87.58px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>If the API access is not a GET request (most often it will be a POST request if not GET), the proxy's support for resending a request can be used to test API authentication.  To do this, first log out of the application, then locate the API request in the proxy log and select the request.</p>

<p><figure>
<span style="width: 624.00px; height: 242.67px;"><img alt="" src="images/image73.png" style="width: 624.00px; height: 242.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>
<h2 id="h.s3sj9ps30tvx"></h2><p>Right-clicking on the selected request will bring up a menu.  Select "Resend" from this menu.</p>
<h2 id="h.huq2pwydt711"><figure>
<span style="width: 241.50px; height: 312.12px;"><img alt="" src="images/image72.png" style="width: 241.50px; height: 312.12px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></h2>
<p>Click "Send" to resend the request.</p>

<p><figure>
<span style="width: 624.00px; height: 184.00px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 184.00px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></p>

<p>When the response comes back, the proxy will highlight the response tab, and display the response.  The application should not return user information, and will likely indicate that the access is not authorized or authenticated.</p>
<h1 id="h.313l37seqz2a"><figure>
<span style="width: 624.00px; height: 178.67px;"><img alt="" src="images/image38.png" style="width: 624.00px; height: 178.67px;" title="">
<figcaption>Add caption here</figcaption>
</span>
</figure></h1>

<h1 id="h.i96tfugoo84q">E11 Mobile application testing</h1>
<h2 id="h.8uim1fdsxml">E11.1 Summary</h2><p>Testing mobile applications is similar to testing browser-based applications in many ways.  Because mobile apps are hosted on devices and have some different characteristics than browser-based apps, the setup is different and some of the browser-based tests are not relevant.  This section reviews the test setup for mobile applications, discusses which of the tests from the web application tests described in this plan are relevant for mobile apps, and highlights some tests and considerations that are unique to mobile applications.</p>
<h2 id="h.jr8jg8hlmmg">E11.2 Exploitability and impact</h2><p>For vulnerabilities that are possible for both mobile and browser based apps, the exploitability and impact are similar, regardless of the platform.  Refer to the discussions of exploitability and impact for the individual vulnerability types in the preceding sections of this document.</p>

<p>Poor authentication controls on network-facing APIs is described in the general vulnerabilities section, but APIs are much more common as interfaces to mobile applications than browser based applications.  The reason is that browser based applications will often return an HTML page in response to a request for information, while mobile apps will often query an API for raw data and then render it for the screen within the mobile application.  </p>

<p>One vulnerability that is specific to mobile applications is failure to check the authenticity of an SSL certificate.  SSL Certificates are usually registered with a "Certificate Authority", which acts as a trusted third party to confirm the identity of the server being connected to.  If an application fails to check this, an attacker's certificate can be accepted by the application, thereby allowing the attacker to intercept the encrypted messages sent and received by the application.  (Note: when a tester's proxy self-signed certificate is added to a mobile device's trusted store, the CA mechanism is bypassed but the device owner marks it as a trusted certificate, allowing the device to accept the proxy's certificate as authentic.)  If a mobile application accepts an SSL certificate without verifying that it is from a trusted source, it can enable a man-in-the-middle attack that could allow an adversary to view the contents of the mobile application's encrypted traffic.  This type of attack is also sometimes called SSL Certificate Spoofing.  </p>

<p>A number of barriers exist to executing a certificate spoofing attack.  Access to the vulnerable mobile app's network transactions are required on a network where the attacker can route the app's traffic through a proxy or similar utility, which can present the attacker's untrusted certificate to the device.  A rogue wifi hotspot is one way such an attack could be attempted.  The impact of a successful attack can be significant, as encrypted transactions containing passwords, authentication tokens, and sensitive information become accessible to the attacker. Another factor that may amplify the impact of an SSL certificate spoofing vulnerability in an app is that after a fix is provided, individual users will not receive the fix unless they update the app on their devices.  (For browser-based applications, the SSL certificate checks are handled by the browser and are not specific to individual applications).</p>
<h2 id="h.kcl39z7wypqk">E11.3 Setup and Testing</h2><p>To test mobile applications, a mobile device must be configured to send its network transactions to a proxy running on a test computer, and the proxy's self-signed SSL certificate must be installed as a trusted certificate on the device.  Detailed instructions for these setup steps can be found in the "Proxy Basics and setup with Browsers and Devices" section of this document.</p>
<h3 id="h.c41szg1g16ya">E11.3.1 Browser-based tests that remain relevant for mobile apps</h3>
<p>Mobile applications differ from browser-based apps in that they implement their own interfaces to the network and and their own functionality to process inputs and information. (Browser-based apps rely on the browser to implement the network interfaces and mechanisms such as cookie handling).   Nonetheless, many of the practices that are important for securing applications and the information they hold are the same or similar to those employed by browser-based applications.</p>

<p>The following table summarizes which of the tests from the preceding sections are applicable to mobile applications testing:</p>

<a id="t.eccd9b543822b17376586cb5d2fefe2c2ade4a3e"></a><a id="t.0"></a><table><tbody><tr><td colspan="1" rowspan="1"><p>Section</p></td><td colspan="1" rowspan="1"><p>Test</p></td><td colspan="1" rowspan="1"><p>Applicable?</p></td><td colspan="1" rowspan="1"><p>Notes</p></td></tr><tr><td colspan="1" rowspan="1"><p>Encryption and TLS</p></td><td colspan="1" rowspan="1"><p>Checks for TLS during transport of sensitive information</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p>SSL configurations</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p>HSTS headers</p></td><td colspan="1" rowspan="1"><p>No</p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p>Sensitive information in URLs</p></td><td colspan="1" rowspan="1"><p>(All tests)</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p>Caching and history</p></td><td colspan="1" rowspan="1"><p>(All tests)</p></td><td colspan="1" rowspan="1"><p>No</p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p>Authentication token and cookie handling</p></td><td colspan="1" rowspan="1"><p>TLS for sensitive cookies</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>If app uses cookies</p></td></tr><tr><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p>Invalidation of cookies at logout</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>If app uses cookies</p></td></tr><tr><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p>Can logout from within the app</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p>Cookie protection flags</p></td><td colspan="1" rowspan="1"><p>No</p></td><td colspan="1" rowspan="1"><p>These flags are relevant for browsers only</p></td></tr><tr><td colspan="1" rowspan="1"><p>Password handling</p></td><td colspan="1" rowspan="1"><p>(All tests)</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>If app uses passwords</p></td></tr><tr><td colspan="1" rowspan="1"><p>Username enumeration</p></td><td colspan="1" rowspan="1"><p>(All tests)</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>If app uses usernames</p></td></tr><tr><td colspan="1" rowspan="1"><p>Websockets</p></td><td colspan="1" rowspan="1"><p>(All tests)</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>Possible but rarely used by mobile apps</p></td></tr><tr><td colspan="1" rowspan="1"><p>Information leakage</p></td><td colspan="1" rowspan="1"><p>(All tests)</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>Pay particular attention to API responses</p></td></tr><tr><td colspan="1" rowspan="1"><p>API authentication controls</p></td><td colspan="1" rowspan="1"><p>(All tests)</p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>APIs more common for mobile apps than browser-based apps</p></td></tr></tbody></table>
<h3 id="h.r03vdv9ggz1i">E11.3.2 SSL Certificate Validation (SSL Certificate Spoofing)ests that are specific to mobile applications</h3><p>As described in this section's Exploitability and Impact discussion, a mobile application that accepts an SSL certificate from an untrusted source can expose the user to a man-in-the-middle attack that allows snooping of the encrypted messages sent and received by the application.</p>

<p>This is straightforward to check using the proxy.  If an application's https traffic is visible in the proxy when the device doesn't have the proxy's SSL certificate installed as a trusted certificate, it indicates that the authenticity of the certificate was not checked.</p>

<p>The tests for this require a familiarity with installing and uninstalling SSL certificates, as described in C4.4 Installing proxy SSL certificate to browser and mobile devices.</p>

<p>To check for a potential SSL Certificate Spoofing vulnerability:</p><ol><li>Use the proxy to verify that the application generates https requests, using a device that has the proxy's SSL certificate installed. This is likely to have already been done during earlier testing. Remove the proxy's certificate from the mobile device being used to test the application, or load the application to a device that has not had the proxy's SSL certificate installed as a trusted certificate. <br>NOTE: if the application does not generate https requests, that indicates that the application does not use encryption, which is potentially a separate issue covered in E2. Encryption and Transport Layer Security.</li>
<li>Exercise the functions of the application under test on the mobile device that does not have the proxy's SSL certificate installed.</li></ol><ul><li>If https requests by the application are logged by the proxy, this indicates that the authenticity of the proxy's certificate was not checked by the app;</li>
<li>If no https requests are logged by the proxy this indicates that the proxy's certificate's authenticity was checked and not accepted by the mobile application.  The application probably won't work correctly and may display a message that it can't connect to the network.</li>
<li>Note that http requests may be generated by the application, and this does not indicate a problem with the certificate checking (since http requests do not rely on the certificate). However, as noted above, unencrypted requests can also compromise user data.</li>
</ul>
